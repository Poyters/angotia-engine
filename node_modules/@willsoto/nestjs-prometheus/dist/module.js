"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PrometheusModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrometheusModule = void 0;
const common_1 = require("@nestjs/common");
const prom_client_1 = require("prom-client");
const constants_1 = require("./constants");
const controller_1 = require("./controller");
/**
 * The primary entrypoint. This should be registered once in the root application module.
 *
 * @public
 */
let PrometheusModule = PrometheusModule_1 = class PrometheusModule {
    static register(options) {
        const opts = PrometheusModule_1.makeDefaultOptions(options);
        PrometheusModule_1.configureServer(opts);
        return {
            module: PrometheusModule_1,
            controllers: [opts.controller],
        };
    }
    static registerAsync(options) {
        var _a;
        const asyncProviders = this.createAsyncProviders(options);
        const controller = (_a = options.controller) !== null && _a !== void 0 ? _a : controller_1.PrometheusController;
        return {
            module: PrometheusModule_1,
            controllers: [controller],
            imports: options.imports,
            providers: [...asyncProviders],
        };
    }
    static createAsyncProviders(options) {
        if (options.useExisting) {
            return [this.createAsyncOptionsProvider(options)];
        }
        else if (!options.useClass) {
            throw new Error("Invalid configuration. Must provide useClass or useExisting");
        }
        return [
            this.createAsyncOptionsProvider(options),
            {
                provide: options.useClass,
                useClass: options.useClass,
            },
        ];
    }
    static createAsyncOptionsProvider(options) {
        /**
         * Not currently supported since there doesn't seem to be a way to get
         * the result of the function during configuration.
         */
        // if (options.useFactory) {
        //   return {
        //     provide: PROMETHEUS_OPTIONS,
        //     useFactory: options.useFactory,
        //     inject: options.inject || [],
        //   };
        // }
        const inject = options.useClass || options.useExisting;
        if (!inject) {
            throw new Error("Invalid configuration. Must provide useClass or useExisting");
        }
        return {
            provide: constants_1.PROMETHEUS_OPTIONS,
            async useFactory(optionsFactory) {
                const userOptions = await optionsFactory.createPrometheusOptions();
                const opts = PrometheusModule_1.makeDefaultOptions(userOptions);
                PrometheusModule_1.configureServer(opts);
                return opts;
            },
            inject: [inject],
        };
    }
    static configureServer(options) {
        if (options.defaultMetrics.enabled) {
            prom_client_1.collectDefaultMetrics(options.defaultMetrics.config);
        }
        Reflect.defineMetadata("path", options.path, options.controller);
    }
    static makeDefaultOptions(options) {
        return {
            path: "/metrics",
            defaultMetrics: {
                enabled: true,
                config: {},
            },
            controller: controller_1.PrometheusController,
            ...options,
        };
    }
};
PrometheusModule = PrometheusModule_1 = __decorate([
    common_1.Module({})
], PrometheusModule);
exports.PrometheusModule = PrometheusModule;
//# sourceMappingURL=module.js.map